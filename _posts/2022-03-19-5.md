---
title: 스프링 핵심원리 - 기본편(6)
categories:
- Spring
- 스프링프레임워크
- 김영한
- TIL
tags:
- Spring
- 스프링프레임워크
- 김영한
- TIL
---

# 의존관계 자동 주입
**다양한 의존관계 주입**   
- 의존 관계 주입 방법
	- 생성자 주입
	- 수정자 주입(setter 주입)
	- 필드 주입
	- 일반 메서드 주입

<br/>
**생성자 주입**   
-  생성자를 통해서 의존 관계를 주입받는 방식
-  생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
-  **불변, 필수** 의존 관계에 사용
-  생성자가 딱 1개만 있을 경우, **@Autowired**를 생략해도 자동 주입이 된다.(스프링 Bean에만 해당)

<br/>
**수정자 주입**   
- setter라 불리는 필드의 값을 수정하는 수정자 메서드를 통해서 의존 관계를 주입하는 방법
- **선택, 변경** 가능성이 있는 의존 관계에 사용
- 자바 Bean 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법

<br/>
**필드 주입**   
- 필드에 의존 관계를 바로 주입하는 방식
- 코드가 간결하지만 외부에서 주입이 불가능해서 테스트가 어렵다는 치명적인 단점이 있다.
- DI 프레임워크가 없으면 아무것도 할 수가 없다.
- 사용 안하는게 좋다.
- 애플리케이션의 실제 코드와 관계없는 테스트 코드, 스프링 설정을 목적으로 하는 @Configuration같은 곳에서만 특별한 용도로 사용

<br/>
**일반 메서드 주입**   
- 일반 메서드를 통해 주입하는 방식
- 한번에 여러 필드를 주입할 수 있다.
- 일반적으로 잘 사용하지 않는다.

> 의존 관계 자동주입은 스프링 컨테이너가 관리하는 스프링 Bean이어야 동작한다.

**옵션 처리**   
주입할 스프링 Bean이 없어도 동작해야 할 때가 있는데, **@Autowired**만 사용하면 **required** 옵션의 기본값이 true로 되어 있어서 자동 주입 대상이 없으면 오류가 발생한다.   
- 자동 주입 대상을 옵션으로 처리하는 방법
	- **@Autowired(required = false)** : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
	- **org.springframework.lang.@Nullable** : 자동 주입할 대상이 없으면 null이 입력된다.
	- **Optional<>** : 자동 주입할 대상이 없으면 Optional.empty 가 입력 된다.

<br/>
**생성자 주입 방법을 선택하자**   
과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다.   

<br/>
**불변**   
- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다.
- 수정자 주입을 사용하면, setXxx 메서드를 public으로 열어두어야 한다.
- 누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

<br/>
**누락**   
- 생성자 주입을 사용하면 주입 데이터를 누락했을 때 **컴파일 오류**가 발생한다.(IDE에서 어떤 값을 필수로 주입해야 하는지 알 수 있다.)

<br/>
**final 키워드**   
- 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다. 그래서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에서 막아준다.
- 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.

<br/>
>  - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다.   
>  - 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.   
>  - 항상 생성자 주입을 선택하고, 가끔 옵션이 필요하면 수정자 주입을 선택하는 것이 좋으며, 필드 주입은 사용하지 않는게 좋다.   
> - **컴파일 오류는 세상에서 가장 빠르고, 좋은 오류다!**

**롬복(lombok)과 최신 트랜드**   
자바의 **annotation processor**를 이용해 컴파일 시점에 constructor, getter, setter 등의 메서드 코드를 자동으로 생성해준다.   
- **@RequiredArgsConstructor** : final이 붙은 필드를 모아서 생성자를 자동으로 만들어준다.
- **@Setter** : 생성된 멤버변수들을 바탕으로 한 setter 메서드를 자동으로 만들어준다.
- **@Getter** : 생성된 멤버변수들을 바탕으로 한 getter 메서드를 자동으로 만들어준다. 
- lombok으로 생성된 메서드들은 코드상에 나타나지는 않지만, 해당 애노테이션을 붙여두면 바로 접근 및 사용이 가능하다.
- [lombok annotations](https://projectlombok.org/features/all)
- build.gradle에 lombok dependencies 설정 -> 라이브러리 설치 (java 11 compile 오류가 발생하면, 자바 언어 설정필요함.) 가 필요하다.

최근에는 생성자를 딱 1개 두고, @Autowired 를 생략하는 방법을 주로 사용한다. 여기에 Lombok 라이브러리의 **@RequiredArgsConstructor** 를 함께 사용하면 필요한 기능은 다 제공하면서, 코드를 더 깔끔하게 사용할 수 있다.

**조회 대상 Bean이 2개 이상일 때 해결 방법**   
- @Autowired 필드 명 매칭
- @Quilifier -> @Quilifier끼리 매칭 -> Bean 이름 매칭
- @Primary 사용

**@AutoWired 필드 명 매칭**   
@Autowired는 타입 매칭을 시도하고, 이때 여러 Bean이 있으면 필드 이름(파라미터 이름)으로 Bean 이름을 추가 매칭한다.

**@Quilifier 사용**   
@Quilifier는 추가 구분자를 붙여주는 방법이다. 주입시 추가적인 방법을 제공하는 것이지, Bean 이름을 변경하는 것은 아니다.
- 플로우   
Quilifier 끼리 매칭 -> 주입된 이름의 Quilifier가 없으면 Bean 이름으로 매칭   
-> **NoSuchBeanDefinitionException** 예외 발생

**@Primary 사용**   
- **@Primary**는 우선순위를 정하는 방법
- @Autowired 시에 여러 Bean이 매칭되면 **@Primary**가 우선권을 가진다.

**@Primary, @Quilifier 활용**   
코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 Bean이 있고, 코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 Bean이 있다고 생각해보자.    
메인 데이터베이스의 커넥션을 획득하는 스프링 Bean은 @Primary를 적용해서 조회하는 곳에서 @Quilifier 지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 Bean을 획득할 때는 @Quilifier를 지정해서 명시적으로 획득하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다.   물론 이때 메인 데이터베이스의 스프링 Bean을 등록할 때 Quilifier를 지정해주는 것은 상관없다.

**@Primary, @Quilifier 우선순위**   
기본적으로 스프링은 **자동보다는 수동**이, **넓은 범위의 선택권 보다는 좁은 범위의 선택권**이 우선 순위가 높다.
@Primary는 기본값 처럼 동작하는 것이고, @Quilifier는 매우 상세하게 동작하는 것이기 때문에 **@Quilifier가 우선권이 높다.**
