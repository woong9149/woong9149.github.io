---
title: "[Nodejs]생활코딩 - Node.js 1"
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
categories:
- nodejs
- 생활코딩
- TIL
tags:
- nodejs
- 생활코딩
- TIL
---

- 초창기 웹은 html만으로도 충분했음   
- 그러나 html을 직접 코딩하는것이 답답하고,  성장의 한계에 봉착함   
- 자바스크립트에 익숙한 웹개발자들이 새로운 언어를 배우지않고도 서버쪽 애플리케이션을 만들 수 있게 하기위해 나온 기술이 nodejs   
  (2008년 구글이 V8 엔진을 개발, V8을 기반으로한 nodejs가 만들어짐)   
- 다른 서버사이드 언어들 처럼 웹브라우저가 아닌 컴퓨터 자체를 제어함   

> **O'REILLY 설명**   
> **Node.js**는 Goole의 V8 JavaScript 엔진에 기반한 서버 측 기술이다. 쓰레드나 별도 프로세스 대신 **비동기 이벤트 위주의 I/O를 사용**하는 고도의 확장성을 가진 시스템으로,   
> **간단한 작업을 수행하지만 접근 빈도가 높은 웹 애플리케이션에 이상적**이다.   
> **Apache**와 같은 전통적인 웹 서버에서는 웹 리소스가 요청될 때마다 요청을 처리하기 위해 매번 별도의 스레드를 생성하거나 새로운 프로세스를 호출하게 된다. Apache가 요청에 빠르게 응답하고, 요청을 만족한 후 정리를 수행하더라도 이러한 접근방법은 여전히 많은 양의 리소스를 붙잡아 두게 된다. 그리하여 인기 있는 웹 애플리케이션은 심각한 성능 문제를 겪게 된다.   
> 반면, Node는 매 요청마다 쓰레드나 프로세스를 새롭게 생성하지 않는다. 그 대신, 특정 이벤트를 기다리고 있다가 해당 이벤트가 발생하면 적절하게 응답한다. Node는 이벤트 기능이 완료되는 것을 기다리는 동안 다른 요청이 들어오는 것을 차단하지 않으며, 이벤트는 비교적 간단한 이벤트 루프 내에서 들어온 순서대로 처리된다.   
> Node 애플리케이션은 JavaScript(혹은 JavaScript로 컴파일 되는 다른 언어)로 작성 된다. 이 JavaScript는 클라이언트 애플리케이션에서 사용하던 것과 동일하다. 하지만 브라우저에서의 JavaScript와 달리, Node에서는 개발 환경을 구성해야 한다.

<br/>
# nodejs 설치

<img width="624" alt="스크린샷 2020-02-01 오후 8 21 10" src="https://user-images.githubusercontent.com/42554237/79306220-ce53a480-7f2f-11ea-9715-bcf035e7eac3.png">

- nodejs runtime을 설치함   
- javascript로 nodejs runtime의 여러가지 기능들을 호출해서 nodejs application을 만드는 것   
- 터미널에서 node -v 를 해서 현재 버전이 나오면 정상설치가 된것   
- 설치 후 터미널에서 node를 입력하고 엔터 후 다음줄에 명령문을 쓰면 결과가 나옴   
- ‘nodejs’ 폴더를 만들고 에디터에서 연 후 js파일에 코드를 입력하고, 터미널로 해당 위치까지 찾아가 js파일을 실행시키면 결과값을 얻을 수 있다.   
<img width="955" alt="스크린샷 2020-02-01 오후 8 29 32" src="https://user-images.githubusercontent.com/42554237/79306340-ff33d980-7f2f-11ea-8cfb-3ffdaea38576.png">   

- nodejs는 웹서버 기능을 가지고있다. 이런 특성을 이용해서 컨텐츠를 프로그래밍적으로 생산할수 있게 된다.(아파치 웹서버와 같음)   
- web 1 수업에서 쓴 코드들을 다운받아, 폴더에 main.js를 추가해서 작동시켜본다.(localhost:3000)   
(터미널 명령어 : node main.js)   
- **response.end()** 명령어로 화면에 띄운다   
<img width="337" alt="스크린샷 2020-02-01 오후 8 50 33" src="https://user-images.githubusercontent.com/42554237/79306402-1e326b80-7f30-11ea-9081-9e91b207120e.png">

# Javascript data type

- 컴퓨터를 사용하는 가장 큰 이유중에 하나는 데이터 때문임   
- 데이터의 종류와 처리하는 방법이 핵심    

# Number type
javascript에서 number타입을 나타낼때는 따옴표 없이 그냥 숫자만 표시   
**+-*/** 등의 사칙연산이 적용 가능하다.   

# String type
**‘’**(홑따옴표) 이나 **“”**(쌍따옴표)으로 감싸면 문자열로 인식.   
1+1을 하면 결과값이 2,   
‘1’ +’1’ 을 하면 11이 됨.   
문자열에 **.length** 를 하면 문자열의 길이를 알 수 있다.   

# 변수의 형식

변수 앞에는 **var** 을 붙인다.(**let**,**const** 도 있음)   
붙이지 않아도 되지만, 붙이지 않아도 되는 이유를 모른다면 그냥 붙이는 게 좋다.(유효범위와 관련이 있음)   

# 변수의 활용

변수의 중요한 의미중 하나는 데이터에 이름을 붙인다는 것.   
좋은 프로그래밍이랑 중복을 제거 한 것인데, 변수를 이용해 중복을 제거할 수 있다.   
변수를 잘 이용하면 코드가 1억줄이더라도 한번에 바꿀 수 있게 된다.   

# Template literal

문자열을 **` `** (키보드의 ~ 키)로 감싸면 **띄워쓰기**, 코드상에서의 **줄바꿈** 등이 그대로 적용된다. 변수는 **${변수명}** 으로 적용시킨다.
**‘’** 를 사용하고 **\n** 을 주는 것 보다 훨씬 수월하다.   

# URL의 이해
<img width="719" alt="스크린샷 2020-02-02 오후 5 28 55" src="https://user-images.githubusercontent.com/42554237/79306685-a44eb200-7f30-11ea-823e-e4b369df99b3.png">

- **protocol** : 통신규약, 웹브라우저와 웹서버의 통신방식   
-**domain(host)** : 인터넷에 연결되어 있는 각 컴퓨터의 이름   
- **port** : 포트번호. 한  대의 컴퓨터에 여러개의 서버가 있을 수 있는데, 클라이언트 입장에서 그 서버들중 어떤 서버와 통신할것인지에 대한 정보를 명시함.(웹서버는 기본값이 80번 포트, 포트번호를 안주면 80번으로 연결됨.)
- **path** : 컴퓨터의 어떤 디렉토리의 어떤 파일인지를 가리킴.
- **query string** : **?** 로 시작함. 값과 값 사이는 **&** 로 연결하고, 값의 이름과 값은 **=** 로 구분함. query string의 값에 따라 보여지는 내용이 다르게 됨.   

# Node.js에서 URL을 통해서 입력된 값을 사용하는 방법

**require()** 를 이용해 nodejs의 **url 모듈**을 사용한다.   
> var url = require(‘url’);   
`parse(_url)`  로 **_url** 의 값을 파싱해 올 수 있다.   

# 동적인 웹페이지 만들기

html의 소스를 **template** 변수에 담고 그 변수를 `response.end(template)`로 응답되게 한다.    
queryString의 값에 따라 제목이 바뀌게 하여 동적으로 페이지를 생성한다.   

# Node.js - 파일 읽기
<img width="514" alt="스크린샷 2020-02-02 오후 7 21 30" src="https://user-images.githubusercontent.com/42554237/79307045-39ea4180-7f31-11ea-9fc6-7a165f3b29c6.png">
`var fs = require(‘fs’)`
를 통해 nodejs의 **fs 모듈**을 사용한다.   

`fs.readFile(filename, [options], callback)`   
filename의 파일을 [options]의 방식으로 읽은 후 callback으로 전달된 함수를 호출합니다. **(비동기적)**   
	   
`fs.readFileSync(filename, [options])`   
filename의 파일을 [options]의 방식으로 읽은 후 문자열을 반환합니다. **(동기적)**   
	   
읽고싶은 파일이 있는 위치와 node를 실행시키는 위치에 따라서 파일이 읽히지 않을 수가 있다.    
일단은 파일이 있는 디렉토리에서 node를 실행시키면 읽을 수 있음.   
다른 디렉토리에 있다면, 파일명을 전달할때 파일명 앞에 경로를 붙여줘야함.